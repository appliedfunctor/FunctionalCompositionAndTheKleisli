<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>reveal.js</title>

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/aworton.css">

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>
	</head>
	<body>
		<div class="reveal">
			<div class="slides">



				<section data-background="lib/images/david-clode-533375-unsplash.jpg">
					<div class="headerBox">
            <h2>Functional Composition and the Kleisli</h2>
            <h3>● ● ●</h3>
            <h3><code><=<</code>
                &nbsp;&nbsp;&nbsp;&nbsp;
                A tale of two fish(es) 
                &nbsp;&nbsp;&nbsp;&nbsp;
                <code>>==></code></h3>
            <br>
            <br>
            <h4>
                Alexander Worton
                <br>
                Scala eXchange 2018
            </h4>
          </div>
        </section>

          <section data-transition="convex-in concave-out" data-background="lib/images/blur-clock-clock-face-280361.jpg">

              <aside class="notes">
                  Complexity is the arch nemesis of better, more correct and more robust software.

                  We are going to look at how we can use functional composition to reduce complexity
                  and give ourselves another approach to writing software to be applied when it makes
                  sense to do so.

                  When it makes sense could range from never to every time, and that will depend on your
                  team, your style, your domain.

                  I love functional programming, it excites me, and I'm very lucky to be working on a team
                  which aligns in style and approach.

                  But everyone is different and the beauty and bain of scala is that it allows for a mix of
                  approaches and styles from OOP and FP that can be combined in a vast number of ways.
              </aside>
          </section>




				<section data-background="lib/images/background.jpg">
					<!-- <section data-transition="none">
				    <h3>Outline</h3>
						<object type="image/svg+xml" data="lib/svg/outline1.svg">
						  Your browser does not support SVG
						</object>
				 </section>
				 <section data-transition="none">
				    <h3>Outline</h3>
						<object type="image/svg+xml" data="lib/svg/outline2.svg">
						  Your browser does not support SVG
						</object>
				 </section>
				 <section data-transition="none">
				    <h3>Outline</h3>
						<object type="image/svg+xml" data="lib/svg/outline3.svg">
						  Your browser does not support SVG
						</object>
				 </section>
				 <section data-transition="none">
				    <h3>Outline</h3>
						<object type="image/svg+xml" data="lib/svg/outline4.svg">
						  Your browser does not support SVG
						</object>
				 </section> -->
				 <section data-transition="none">
				    <h3>Outline</h3>
						<object type="image/svg+xml" data="lib/svg/outline5.svg">
						  Your browser does not support SVG
						</object>
				 </section>
				</section>






				<section 
					data-transition="convex-in concave-out" data-background="lib/images/books-bookshelf-encyclopedia-34592.jpg">

					<div class="headerBox">
						<h2 class="stroke">Functional composition</h2>
						<br>
						<h3 class="stroke">using the standard library</h3>
					</div>

					<aside class="notes">

                        To start we'll look at what a function is and how we can compose using the standard library
                        then we'll look at composing with higher kinded types
                        before considering configuration injection.



						<ul>
							<li>What is a function?</li><br>
							<li>What is composition?</li><br>
							<li>The standard library:</li><br>
							<ul>
								<li>compose</li><br>
								<li>andThen</li><br>
							</ul>
						</ul>
					</aside>
				</section>



				<section data-background="lib/images/background.jpg">


					<section data-transition="convex-in concave-out">
						<h2>What is a function?</h2>
						<br>
						<pre class="scala"><code data-trim>
							object Main extends App {

								def backwards(input: String): String = {
									input.reverse
								}

								println(backwards("fish"))
							}
						</code></pre>
                        <aside class="notes">

                            I'd like to take you back in time, to when you first encountered Scala.
                            If your experience was anything like mine, then you probably encountered a def like this.
                            Even if the syntax is a little different, it's fairly easy to recognise the argument,
                            return type and implementation, I'd say that it's quite familiar whether you've come from
                            Java, Javascript, C# or Python, In fact it's very similar to python, uses a def keyword and
                            everything.

                            It looks like a function, it walks and talks like a function. In fact if we were using python,
                            it would be a function, but In Scala, we're a little more strict with our typing.

                            The problem with this is, that despite how accessible it is when you come to Scala, it isn't
                            actually a function. It's a method.


                            <ul>
                                <li>Take you back in time, first encountered Scala</li><br>
                                <li>Not a function -> is a method.</li><br>
                            </ul>
                        </aside>
					</section>



					<section data-transition="convex-in concave-out">
						<h2>A method</h2>
						<br>
						<pre class="scala"><code data-trim data-noescape>
							object Main extends App {

								def backwards(input: String): String = {
									input.reverse
								}

								def getBackwards: String => String = {
									input => input.reverse
								}

								println(backwards("fish"))
								println(getBackwards("fish"))
								<mark><s>val fn = backwards</s></mark>
								val fn2 = getBackwards
							}
						</code></pre>
                        <aside class="notes">

                            So if what we've just seen is not a function, but a method, then what is a function,
                            what is a method and what is the difference?

                            Let's illustrate this with an example.

                            Here we have backwards which is a method that returns a string. We know this because the return
                            type is a String.

                            getBackwards is a method that takes no arguments and returns a function of String to String,
                            that is the return type is a function with the same signature as backwards, it takes a string
                            and returns a string.

                            You can use these in the same way, applying them with an argument yields a result that you
                            can print, but when we try to assign the 'functions' to variables, getBackwards works, but
                            backwards does not.

                            <ul>
                                <li>So what's a method, what's a function?</li><br>
                                <li></li><br>
                                <li></li><br>
                            </ul>
                        </aside>
					</section>



					<section data-transition="convex-in concave-out">
						<h2>Retrieving the function from a method</h2>
						<br>
						<pre class="scala"><code data-trim data-noescape>
							object Main extends App {

								def backwards(input: String): String = {
									input.reverse
								}

								<mark><s>val back = backwards</s></mark>
								val back2 = backwards _
								val back3: String => String = backwards

								println("back2: " + back2("reverse me"))
								println("back3: " + back2("reverse me"))
							}
						</code></pre>
                        <aside class="notes">
                            Now, we can actually take the function from a method and store it in a val, but we need to
                            give the compiler a little more explicit information to do so.

                            As seen, just assigning it to a val won't work, because there's a little more work that needs
                            to be done in order to be able to pass a function around as a variable.

                            Applying using an underscore or explicitly stating the type of the val is enough to trigger
                            this, but this shows us that there is a difference between a method and a function.
                        </aside>
					</section>


					<section data-transition="convex-in concave-out">
						<h2>A function value</h2>
						<br>
						<pre class="scala"><code data-trim>
							object Main extends App {

								val backwards: String => String = input => {
									input.reverse
								}

								println(backwards("fish"))
							}		
						</code></pre>
                        <aside class="notes">
                            We can store a function as a val, and unlike the def, this is a function.
                            previously, we saw that a def could create a function, and be coerced to return a function
                            but in this case we are directly assigning it.

                            There is an important distinction.

                            A val is eagerly evaluated, that is the value is evaluated and assigned when the val is
                            declared, however this occurs once.

                            A def is evaluated every time it is called.

                        </aside>
					</section>


					<section data-transition="convex-in concave-out">
						<h2>A lazy function value</h2>
						<br>
						<pre class="scala"><code data-trim>
							object Main extends App {

								lazy val backwards: String => String = input => {
									input.reverse
								}

								println(backwards("fish"))
							}		
						</code></pre>
                        <aside class="notes">
                            A lazy val is like a regular val, but it isn't evaluated when it's declared, it's evaluated
                            when first called or used.

                            So if we don't call it, it never gets evaluated

                            If we call or use it three times, the right hand side is evaluated once, on the first use.

                            So now we know that
                                - a def is evaluated every time you call it, just like a function
                                - a val is evaluated once, when declared
                                - a lazy val is evaluated once, the first time it is used.

                            Let's look at what a function is.

                        </aside>
					</section>


					<section data-transition="convex-in concave-out">
						<h2>Function1[A, B]</h2>
						<br>
						<pre class="scala"><code data-trim>
							Object Main extends App {

								val backwards = new Function1[String, String] {
									override def apply(input: String) = 
										input.reverse
								}

								println(backwards("fish"))
							}
						</code></pre>
                        <aside class="notes">
                            A function as we pass it around in scala is object, so you can think of a function as being
                            an instance of a particular trait that exists on the heap.

                            When we assign a function to a val, we store the memory location of the function object in
                            the val.

                            When we apply a function, we call the object's apply method with the arguments

                            Here we are explicitly
                            creating a function1 object which takes two type parameters. The first is the input and the
                            second the output of the function.

                            In fact, String => String is syntactic sugar for this object.

                            This is important when thinking about how a def is evaluated on every call. If you return a
                            function from a def, you are creating a new function object every time it's called.

                        </aside>
					</section>


					<section data-transition="convex-in concave-out">
						<h2>Function0[+R]</h2>
						<br>
						<pre class="scala"><code data-trim>
							Object Main extends App {

								// () => String
								val backwards = new Function0[String] {
								override def apply() = "fish".reverse
							  }

							  println(backwards())
							}
						</code></pre>
                        <aside class="notes">
                            The function1 defines a function with 1 input parameter, but it is not the only function
                            trait. There are as many function traits as there are tuples, 23 of them from 0 to 22.

                            A function0 as seen here is a zero argument function, the same as empty brackets to something.

                        </aside>
					</section>

				</section>



				<section data-background="lib/images/background.jpg">

					<section data-transition="convex-in concave-out">
						<h2>What is composition?</h2>		
						<br>				
						<pre class="scala"><code data-trim>
							val double: Int => Int = _ * 2	// (number => number * 2)

							val inc: Int => Int = _ + 1	// (number => number + 1)
						</code></pre>

                        <aside class="notes">
                            We've seen the syntactic sugar describing function signatures now. Here we have two
                            functions with references stored in vals; double and inc.

                            These have been implemented using the abbreviated syntax, which is the same as
                            a to a * 2 and number => number + 1.

                            composition is a means to take multiple functions and put them together to produce
                            a combined effect.

                        </aside>

					</section>		

					<section data-transition="convex-in concave-out">
						<h2>Chaining application</h2>		
						<br>				
						<pre class="scala"><code data-trim>
							val double: Int => Int = _ * 2	// (number => number * 2)

							val inc: Int => Int = _ + 1	// (number => number + 1)
						</code></pre>

						<br>
						<pre class="scala"><code data-trim>
							val doubled = double(5)

							val incremented = inc(doubled)
						</code></pre>

                        <aside class="notes">
                            We can achieve this most easily by chaining application of the functions.
                            Here we apply double with the input 5 and then we take the output of that function
                            call and feed it in to the second function as an argument.
                        </aside>
					</section>		

					<section data-transition="convex-in concave-out">
						<h2>Nesting (inline)</h2>		
						<br>				
						<pre class="scala"><code data-trim>
							val double: Int => Int = _ * 2	// (number => number * 2)

							val inc: Int => Int = _ + 1	// (number => number + 1)
						</code></pre>

						<br>

						<pre class="scala"><code data-trim>
							val result = inc(double(5))	// 11
						</code></pre>

                        <aside class="notes">
                            This can also be achieved by inlining the function calls rather than storing the
                            intermediate result in a val.

                            However, it would be even more useful to be able to compose functions without applying
                            them, that way we could reuse  blocks of logic by composing them from other functions
                            whether those other functions are simple single functions or composed blocks themselves.
                        </aside>

					</section>		


					<section data-transition="convex-in concave-out">
						<h2>Compose without applying</h2>		
						<br>				
						<pre class="scala"><code data-trim>
							val doubleAndIncrement: Int => Int = number => {

									inc(double(number))

							}

						</code></pre>

                        <aside class="notes">
                            To achieve this we could create a new function

                            This delays the execution of the composed functions until we apply this function and
                            pass in the input argument.

                            then it feeds into the first and executes down the chain until it returns the output from
                            the tail.

                            However the syntax here doesn't scale very well, it becomes harder to read as you increase
                            the depth of nesting.

                            And you have the added difficulty of attempting to read the chain from right to the left.

                            Let's look at what other options there are.
                        </aside>

					</section>		


					


				</section>


				<section data-background="lib/images/background.jpg">

					<section data-transition="convex-in concave-out" data-background="lib/images/giammarco-boscaro-380903-unsplash.jpg">
						<div class="headerBox">
							<h2>What else does the standard library provide?</h2>	
						</div>
					</section>	


					<section data-transition="convex-in concave-out">
						<h2>The `compose` function</h2>		
						<br>				
						<pre class="scala"><code data-trim>
							trait Function1[-T1, +R] {

								def compose[A](g: (A) => T1): (A) => R

							}
						</code></pre>		

						<br>
						<h5>in use</h5>
						<pre class="scala"><code data-trim>
							val doubleAndIncrement: Int => Int = inc.compose(double)

							val doubleAndIncrement: Int => Int = inc compose double

							val result = doubleAndIncrement(5) // 11
						</code></pre>

                        <aside class="notes">
                            So we have the compose function.

                            and what this does is allow you to provide another function as an argument to your current
                            function and it will compose the two functions into a new function, just like we did manually
                            where the other function is applied, followed by the current function.

                            This operates just like the dot compose notation in maths where a dot b produces as function
                            where the argument is first applied to b and then the output of that is applied to a.

                            or in this case whatever is passed in is doubled and then incremented.

                        </aside>

					</section>	


					<section data-transition="convex-in concave-out">
						<h2>Reading right to left</h2>		
						<br>				
						<pre class="scala"><code data-trim>
							val doThing: Int => Int = inc compose

											double compose

												inc compose

													triple
						</code></pre>

                        <aside class="notes">
                            So we have improved the readability somewhat using the compose method by avoiding the
                            nested calls, and we can use whitespace to make it a little easier still

                            but we're still stuck with this problem where we have to read from right to left.

                            If that's easier for you then compose is your function and you can stop there.

                            If it's not however, there is another method provided to us that we can use instead.

                        </aside>
					</section>	


					<section data-transition="convex-in concave-out">
						<h2>andThen</h2>		
						<br>				
						<pre class="scala"><code data-trim>
							trait Function1[-T1, +R] {

								def andThen[A](g: (R) => A): (T1) => A

							}
						</code></pre>		
						<br>
						<h5>In use</h5>
						<pre class="scala"><code data-trim>
							val incrementAndDouble: Int => Int = inc.andThen(double)

							val incrementAndDouble: Int => Int = inc andThen double

							val result = incrementAndDouble(5) // 12
						</code></pre>

                        <aside class="notes">
                            and it's called andThen. it works exactly the same as compose only the order of
                            composition is reversed.

                            so if we use it to cokpose inc and double, it will apply inc first, followed by double

                            whcih has the effect of switching the reading order of the composed functions from
                            right to left to left to right.

                        </aside>
					</section>	


					<section data-transition="convex-in concave-out">
						<h2>Reading left to right</h2>		
						<br>				
						<pre class="scala"><code data-trim>
							val doThing: Int => Int = inc andThen

											double andThen

												inc andThen

													triple
						</code></pre>

                        <aside class="notes">
                            I personally prefer this style, I find it easier to read and reason about, but as
                            we've seen, you have the choice. So use whatever works best for you.

                        </aside>
					</section>	


					<section data-transition="convex-in concave-out" id="fragments">
						<h2>The signature for chaining</h2>		
						<br>	

						<q>The output from the previous function must match the input to the next function in your chain</q> 

						<br>
						<br>

						<pre class="scala fragment"><code data-trim>
							val a: Config => DbResult
							val b: DbResult => BigInt
							val c: BigInt => BigInt
							val d: BigInt => Json

							val e: Config => Json = a andThen b andThen c andThen d
						</code></pre>

                        <aside class="notes">
                            We've seen this already, but I just want to be explicit and clear that in order to
                            compose functions, the signatures must match.

                            If your output from one function is a String, then the next function in the chain must take
                            a string as it's input.
                        </aside>
					</section>	





					<section data-transition="convex-in concave-out">
						<h2>Can't compose, won't compose</h2>		
						<br>		

						<pre class="scala"><code data-trim data-noescape>
							val unitNum: Unit => Int = Unit => 5

							val double: Int => Int = _ * 2

							val result = unitNum andThen double //Function1[Unit, Int]

							<span class="fragment" data-fragment-index="1">// no Function1[(), Int] Function0[Int]</span>
							val laterNum = () => 5
							<br>
							<span class="fragment" data-fragment-index="1"><mark><s>val other = laterNum andThen double</s></mark></span>

							
						</code></pre>

                        <aside class="notes">
                            before we wrap up this section, I'd like to highlight a few gotchas.

                            result here is perfectly fine.

                            unitNum is a function of Unit to Int and double is an Int to Int.

                            the signatures line up and we can compose them.

                            -slide change-

                            however if we have laterNum, and try to substitute it for unitNum, it won't work.

                            this is because empty brackets is treated as no arguments, which means that laterNum
                            is not a function1[Unit, Int], but a function0[Int]

                            and of all 23 functions, only function1 has the methods compose and andThen defined
                            on it.
                        </aside>

					</section>	


				</section>

				<section data-background="lib/images/background.jpg">

						<section 
							data-transition="convex-in concave-out">
							<div>
								<h2>Composing</h2>
								<br>
								<h3>with higher kinded types</h3>
							</div>
							<aside class="notes">
								<ul>
									<li>The standard library:</li><br>
									<ul>
										<li>map</li><br>
										<li>flatMap</li><br>
									</ul>
									<li>The Kleisli</li><br>
								</ul>
							</aside>
						</section>

						<section data-background="lib/images/george-bonev-296136-unsplash.jpg">
						</section>


						<section data-background="lib/images/tanguy-sauvin-3121-unsplash.jpg">
						</section>


						<section data-transition="convex-in concave-out">
						<h2>The problem composing with a context</h2>		
						<br>				
						<pre class="scala"><code data-trim>
							val getEmployeeFromDb: Id => IO[Employee]

							val processEmployee: Employee => IO[Employee]

							val updateEmployeeInDb: Employee => IO[Int]
						</code></pre>

                        <aside class="notes">
                            Quite commonly, you'll have functions inside a context such as a Future, Task or IO, and this presents a problem. As we've already seen, in order to compose, our output from one function must form the input to the next.
                        </aside>
						</section>	

						<section data-transition="convex-in concave-out">
						<h2>Solution 1 - flatMap</h2>		
						<br>				
						<pre class="scala"><code data-trim>
							val comboFlatMap: Id => IO[Boolean] = id => 
						    getEmployeeFromDb(id) flatMap { employee => 
						        processEmployee(employee) flatMap { processed =>
						            updateEmployeeInDb(processed)
						        }
						    }
							
						</code></pre>

                        <aside class="notes">
  
                        </aside>
						</section>	

						<section data-transition="convex-in concave-out">
						<h2>Solution 2 - For comprehension</h2>		
						<br>				
						<pre class="scala"><code data-trim>
							val comboForComp: Unit => IO[Boolean] = id =>
							    for {
							        employee <- getEmployeeFromDb(id)
							        processed <- processEmployee(employee)
							        result <- updateEmployeeInDb(processed)
							    } yield result
						</code></pre>

                        <aside class="notes">
                           
                        </aside>
						</section>	

						<section data-transition="convex-in concave-out">
						<h2>Solution 3 - The Kleisli</h2>		
						<br>				
						<pre class="scala"><code data-trim>
							val fn: Int => IO[String] = ???
							val fnK: Kleisli[IO, Int, String] = ???
						</code></pre>

                        <aside class="notes">
                            
                        </aside>
						</section>	


						<section data-transition="convex-in concave-out">
						<h2>Lifting into a Kleisli</h2>		
						<br>				
						<pre class="scala"><code data-trim>
							val getEmployeeFromDb: Id => IO[Employee] = ???

							val getEmployeeFromDbK = Kleisli.apply(getEmployeeFromDb)

							val getEmployeeFromDbK = Kleisli(getEmployeeFromDb)
						</code></pre>

                        <aside class="notes">
                            
                        </aside>
						</section>	


						<section data-transition="convex-in concave-out">
						<h2>Combining Kleisli</h2>		
						<br>				
						<pre class="scala"><code data-trim>
							val getEmployeeFromDbK: Kleisli[IO, Id, Employee] = ???
							val processEmployeeK: Kleisli[IO, Employee, Employee] = ???
							val updateEmployeeInDbK: Klesili[IO, Employee, Int] = ???

							val comboKleisli: Kleisli[IO, Id, Int] = 
								getEmployeeFromDbK
									andThen processEmployeeK
										andThen updateEmployeeInDbK
						</code></pre>

                        <aside class="notes">
                            
                        </aside>
						</section>	

						<section data-transition="convex-in concave-out">
						<h2>Combining and lifting Kleisli</h2>		
						<br>				
						<pre class="scala"><code data-trim>
							val comboKleisli: Kleisli[IO, Id, Int] = 
								Kleisli(getEmployeeFromDb)
									andThenK processEmployee
										andThenK updateEmployeeInDb
						</code></pre>

                        <aside class="notes">
                            
                        </aside>
						</section>

						<section data-transition="convex-in concave-out" data-background="lib/images/chase-clark-509084-unsplash.jpg">
							<div class="headerBox">
								<h2>I put on my robe<br>and wizard hat...</h2>		
							</div>
						</section>

						<section data-transition="convex-in concave-out">
							<pre class="scala"><code data-trim>
							val comboKleisli: Kleisli[Task, Id, Int] = 
								Kleisli(getEmployeeFromDb)
									>=> Kleisli(processEmployee)
										>=> Kleisli(updateEmployeeInDb)
						</code></pre>
						<br>
						<pre class="scala"><code data-trim>
							val comboKleisli: Kleisli[Task, Id, Int] = 
								Kleisli(getEmployeeFromDb)
									>==> processEmployee
										>==> updateEmployeeInDb
						</code></pre>

            <aside class="notes">
                
            </aside>
						</section>


						<section data-transition="convex-in concave-out">
						<h2>Extracting from a Kleisli</h2>		
						<br>				
						<pre class="scala"><code data-trim>
							comboFn: Id => IO[Int] = 
								(Kleisli(getEmployeeFromDb)
									andThenK processEmployeeK
										andThenK updateEmployeeInDbK).run
						</code></pre>

                        <aside class="notes">
                            
                        </aside>
						</section>	

				</section>

				<section data-background="lib/images/background.jpg">
						<section data-transition="convex-in concave-out">
							<h2>What are the benefits?</h2>
							<aside class="notes">
								
							</aside>
						</section>

						<section data-transition="convex-in concave-out">
							<div>
								<h2>Readability</h2>
								<pre class="scala"><code data-trim>
									
								</code></pre>
								
							</div>
							<aside class="notes">
								
							</aside>
						</section>


						<section data-transition="convex-in concave-out">
							<div>
								<h2>Reusability</h2>
								<pre class="scala"><code data-trim>
									
								</code></pre>
								
							</div>
							<aside class="notes">
								
							</aside>
						</section>

						<section data-transition="convex-in concave-out">
							<div>
								<h2>Robustness (Testing)</h2>
								<pre class="scala"><code data-trim>
									val amsGetFilesForProdId: ProductionId => IO[List[File]] =
										_ => IO.pure(amsFiles)
								</code></pre>
								
							</div>
							<aside class="notes">
								
							</aside>
						</section>

						<section data-transition="convex-in concave-out">
							<div>
								<h2>Downside</h2>
								
								Time investment to understand 
								
							</div>
							<aside class="notes">
								
							</aside>
						</section>


				</section>

				<section data-background="lib/images/background.jpg">
						<section 
							data-transition="convex-in concave-out">
							<div>
								<h2>Injecting Configuration</h2>
								
							</div>
							<aside class="notes">
								<ul>
									<li>Why use functional composition?</li><br>
									<li>Testing</li><br>
								</ul>
							</aside>
						</section>
				</section>




				<!-- SUMMARY -->

				<section data-background="lib/images/background.jpg">

						<section 
							data-transition="convex-in concave-out">
							<div>
								<h2>Summary</h2>
								
							</div>
							<aside class="notes">
								<ul>
									<li>Why use functional composition?</li><br>
									<li>Testing</li><br>
								</ul>
							</aside>
						</section>

						<section>
							<h2>Thanks</h2>
							<h4>Pixabay</h4>
							<strong>Clock face</strong> photo by Thomas Breher<br>
							<strong>Books</strong> photo by Unknown<br>
							<br>
							<h4>Unsplash</h4>

							<strong>Fish</strong> Photo by David Clode
							<strong>Blue Lego</strong> Photo by Iker Urteaga
							<strong>Cat in a box</strong> photo by George Bonev<br>
							<strong>Turtle</strong> Photo by Tanguy Sauvin<br>
							<strong>Bookshelf with ladder</strong> Photo by Giammarco Boscaro
							<strong>Wizard</strong> Photo by David Clode

							

						</section>

						<section>
							<h3>Slides?</h3>
							https://github.com/aworton
							<br><br>
							<h3>Follow?</h3>
							twitter: @ajsworton
							<br>linkedIn: Alexander Worton

						</section>

						<section>
							<br>
							<br>
							This presentation will be soon available on the Scala eXchange London website at the following link: 
							<br><br>https://skillsmatter.com/conferences/10488-scala-exchange-2018#skillscasts

							<br><br>The tutorial video is available at:
							<br><br>https://www.youtube.com/watch?v=qL6Viix3npA

						</section>

				</section>


			</div>
		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>
			// More info about config & dependencies:
			// - https://github.com/hakimel/reveal.js#configuration
			// - https://github.com/hakimel/reveal.js#dependencies
			Reveal.initialize({
				dependencies: [
					{ src: 'plugin/markdown/marked.js' },
					{ src: 'plugin/markdown/markdown.js' },
					{ src: 'plugin/notes/notes.js', async: true },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
				]
			});
		</script>
	</body>
</html>
