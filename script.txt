Complexity is the arch nemesis of better, more correct and more robust software.

We are going to look at how we can use functional composition to reduce complexity and give ourselves another approach to writing software to be applied when it makes sense to do so.

When it makes sense could range from never to every time, and that will depend on your team, your style, your domain.

I love functional programming, it excites me, and I'm very lucky to be working on a team which aligns in style and approach.

But everyone is different and the beauty and bain of scala is that it allows for a mix of approaches and styles from OOP and FP that can be combined in a vast number of ways.

----------------------------------------------------------------------------------------
To start we'll look at what a function is and how we can compose using the standard library  then we'll look at composing with higher kinded types before considering configuration injection.
----------------------------------------------------------------------------------------
I'd like to take you back in time, to when you first encountered Scala. If your experience was anything like mine, then you probably encountered a def like this. Even if the syntax is a little different, it's fairly easy to recognise the argument, return type and implementation, I'd say that it's quite familiar whether you've come from Java, Javascript, C# or Python, In fact it's very similar to python, uses a def keyword and everything.

It looks like a function, it walks and talks like a function. In fact if we were using python, it would be a function, but In Scala, we're a little more strict with our typing.

The problem with this is, that despite how accessible it is when you come to Scala, it isn't actually a function. It's a method.
----------------------------------------------------------------------------------------
So if what we've just seen is not a function, but a method, then what is a function,
what is a method and what is the difference?

Let's illustrate this with an example.

Here we have backwards which is a method that returns a string. We know this because the return type is a String. Another great thing about statically typed languages.

getBackwards is a method that takes no arguments and returns a function of String to String, that is the return type is a function with the same signature as backwards, it takes a string and returns a string.

You can use these in the same way, applying them with an argument yields a result that you can print, but when we try to assign the 'functions' to variables, getBackwards works, but backwards does not.
----------------------------------------------------------------------------------------
Now, we can actually take the function from a method and store it in a val, but we need to give the compiler a little more explicit information to do so.

As seen, just assigning it to a val won't work, because there's a little more work that needs to be done in order to be able to pass a function around as a variable.

Applying using an underscore or explicitly stating the type of the val is enough to trigger this, but the key take away here, is that it shows us that there is a difference between a method and a function.

They are not the same thing.
----------------------------------------------------------------------------------------
We can store a function as a val, and unlike the def, this is a function. In fact, every time you see that arrow operator, you know it's syntactic sugar for a function.

Previously, we saw that a def could create a function, and be coerced to return a function but in this case we are directly assigning it.

There is an important distinction.

A val is eagerly evaluated, that is the value is evaluated and assigned when the val is declared, however this occurs once.

A def is evaluated every time it is called.
----------------------------------------------------------------------------------------
A lazy val is like a regular val, but it isn't evaluated when it's declared, it's evaluated when first called or used.

So if we don't call it, it never gets evaluated

If we call or use it three times, the right hand side is evaluated once, on the first use.

So now we know that
    - a def is evaluated every time you call it, just like a function
    - a val is evaluated once, when declared
    - a lazy val is evaluated once, the first time it is used.

Let's look at what a function is.
----------------------------------------------------------------------------------------
A function as we pass it around in scala is object, so you can think of a function as being an instance of a particular trait that exists on the heap in memory.

When we assign a function to a val, we store the memory location of the function object in the val.

When we apply a function, we call the object's apply method with the arguments

Here we are explicitly creating a function1 object which takes two type parameters. The first is the input and the second the output of the function.

In fact, String => String is syntactic sugar for this object.

This is important when thinking about how a def is evaluated on every call. If you return a function from a def, you are creating a new function object every time it's called.
----------------------------------------------------------------------------------------
The function1 defines a function with 1 input parameter, but it is not the only function
trait. 

There are as many function traits as there are tuples, 23 of them from 0 to 22.

A function0 as seen here is a zero argument function, the same as empty brackets to something.
----------------------------------------------------------------------------------------
We've seen the syntactic sugar describing function signatures now. Here we have two
functions with references stored in vals; double and inc.

These have been implemented using the abbreviated syntax, which is the same as
a to a * 2 and number => number + 1.

composition is a means to take multiple functions and put them together to produce a combined effect.
----------------------------------------------------------------------------------------
We can achieve this most easily by chaining application of the functions.
Here we apply double with the input 5 and then we take the output of that function call and feed it in to the second function as an argument.
----------------------------------------------------------------------------------------
This can also be achieved by inlining the function calls rather than storing the intermediate result in a val.

However, it would be even more useful to be able to compose functions without applying them, that way we could reuse blocks of logic by composing them from other functions whether those other functions are simple single functions or composed blocks themselves.

----------------------------------------------------------------------------------------
If we wanted to produce something reusable rather than eagerly composing on the fly we could create a new function.

This delays the execution of the composed functions until we apply this function and pass in the input argument.

then it feeds into the first and executes down the chain until it returns the output from the tail.

However the syntax here doesn't scale very well, it becomes harder to read as you increase the depth of nesting.

And you have the added difficulty of attempting to read the chain from right to the left.

Let's look at what other options there are.
----------------------------------------------------------------------------------------
So we have the compose function.

and what this does is allow you to provide another function as an argument to your current function and it will compose the two functions into a new function, just like we did manually where the other function is applied, followed by the current function.

This operates just like the dot compose notation in maths where a dot b produces as function where the argument is first applied to b and then the output of that is applied to a.

or in this case whatever is passed in is doubled and then incremented.
----------------------------------------------------------------------------------------
So we have improved the readability somewhat using the compose method by avoiding the nested calls, and we can use whitespace, just like you do in Python, to make it a little easier still.

but we're still stuck with this problem where we have to read from right to left.

If that's easier for you then compose is your function and you can stop there.

If it's not however, there is another method provided to us that we can use instead.
----------------------------------------------------------------------------------------
and it's called andThen. it works exactly the same as compose only the order of composition is reversed.

so if we use it to compose inc and double, it will apply inc first, followed by double

which has the effect of switching the reading order of the composed functions from right to left to left to right.
----------------------------------------------------------------------------------------
I personally prefer this style, I find it easier to read and reason about, but as we've seen, you have the choice. So use whatever works best for you.
----------------------------------------------------------------------------------------
We've seen this already, but I just want to be explicit and clear that in order to compose functions, the signatures must match.

If your output from one function is a String, then the next function in the chain must take a string as it's input.

-slide-

here we have a config to db result ......

and because each signature in the chain matches up, we can produce a composed function of a andThen b andthen c andthen d, however we couldn't do a compose b compose c compose d, because that's the same as d andThenc andThen b andThen a.
----------------------------------------------------------------------------------------
before we wrap up this section, I'd like to highlight a few gotchas.

result here is perfectly fine.

unitNum is a function of Unit to Int and double is an Int to Int.

the signatures line up and we can compose them.

-slide change-

however if we have laterNum, and try to substitute it for unitNum, it won't work.

this is because empty brackets is treated as no arguments, which means that laterNum
is not a function1[Unit, Int], but a function0[Int]

and of all 23 functions, only function1 has the methods compose and andThen defined
on it.

Now, this brings us to the end of what we're going to look at with the standard library.
----------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------
Let me present you with a common problem, and to do so let us introduce the 
M word, by which of course I mean Monad.

If you are unfamiliar with them, for the purposes of our functional composition, you
think of them as a context or a box which wraps a value or type. 

Kind of like how a variable is a box with a value in it, so that if you had: val x, x written on the front of the box, equals 5 - 5 stuffed into the box.

A monad is a different kind of box that you set up that takes a type, which is a fancy way of saying it's a generic type - you have to provide the wrapped type to construct your new monad type. 

The box provides context, A list is a Monad. If it's a List of Ints, then that is very different to an option of Int - also a Monad.

but you can have monad with more than one type or with types that wrap other types, in fact it's turtles all the way down, until you hit elephants.

That's a gross oversimplification of course, because I didn't tell you the colour or the type of the elephants. 


Importantly, Monads have a few particular methods on them, one of which is flatMap. Map lets you pass in a function to be applied to the type inside the monad, and flatten allows you to squash nested types. So if your function produced a List[List[String]], flatten would squash this structure down to a List[String].

FlatMap combines these effects.

----------------------------------------------------------------------------------------

Quite commonly, you'll have functions inside a context such as a Future, Task or IO, and this presents a problem. As we've already seen, in order to compose, our output from one function must form the input to the next.

When we start calling functions that wrap that result inside a Future say, we have to a make a decision. we could simply write our functions to take a Future[Boolean] or IO[Boolean] as the input, but this might result in a set of small building blocks which are less composable or interchangable with other components. You may also feel that it pollutes the signatures.

----------------------------------------------------------------------------------------

Solution 1 - flatMap

val comboFlatMap: Unit => Task[Boolean]  = _ => {
    getEmployeeFromDb() flatMap { employee => 
        processEmployee(employee) flatMap { processed =>
            updateEmployeeInDb(processed)
        }
    }
}

This is very similar to the first way we approached composition, we are nesting our calls, we're delaying evaluation using the function we've created to wrap the composition, we just have the additional need to nest the flatMaps here as well.

All in all it works, but it's not particularly easy to read.

Let's go one better, using a feature of the standard library.
----------------------------------------------------------------------------------------

Solution 2 - For comprehension

val comboFlatMap: Unit => Task[Boolean]  = _ => 
    for {
        employee <- getEmployeeFromDb()
        processed <- processEmployee(employee)
        result <- updateEmployeeInDb(processed)
    } yield result



So this is basically syntactic sugar for the hand cranked flatMap we've just seen and it's probably the most common form of handling this sort of monadic chain that you probably see. I think that's because it's much more readable, while doing the job.

The opening line in the for comp sets the context of the comprehension, so in this case, the context is a Task, which the result when yielded will be wrapped in. So even though we have a handle on result as a boolean inside, the return value will be a Task[Boolean]

However, we're still reliant on wrapping this eager composition inside a function call in order to delay it. 

It would be nice if we could achieve what we did with the standard libraries compose and andThen, wouldn't it?

And so we meet the Kleisli
----------------------------------------------------------------------------------------

Solution 3 - The Kleisli

val fn: Int => Task[String] = ???
val fnK: Kleisli[Task, Int, String] = ???

The Kleisli allows us to compose functions while ignoring the context on the outputs. You can think of this as being like a Monad Transformer for functions.

If we have a function with a signature of Int => Task[String], then when we lift that into the context of a Kleisli (again, another monad, turtles all the way down), we get a signature of Kleisli[Task, Int, String], that is the context is the first type parameter, the input the second and the extracted return type the third.
----------------------------------------------------------------------------------------
To lift a function into the context of a Kleisli, you call the apply method on the Kleisli. As we've seen, this can be explicitly or in the more usual syntax
getEmployeeFromDb: Id => Task[Employee] = ???
getEmployeeFromDbKleisli: Kleisli[Task, Id, Employee] = Kleisli.apply(getEmployeeFromDb)
getEmployeeFromDbKleisli: Kleisli[Task, Id, Employee] = Kleisli(getEmployeeFromDb)
----------------------------------------------------------------------------------------
getEmployeeFromDbKleisli: Kleisli[Task, Id, Employee] = Kleisli(getEmployeeFromDb)
processEmployeeKleisli: Kleisli[Task, Employee, Employee] = Kleisli(processEmployee)
getEmployeeFromDbKleisli: Kleisli[Task, Employee, Int] = Kleisli(getEmployeeFromDb)

comboKleisli: Kleisli[Task, Id, Int] = getEmployeeFromDbKleisli 
                                            andThen processEmployeeKleisli 
                                                andThen getEmployeeFromDbKleisli

Now we are back to when we used the standard library for combining functions using methods defined on the Function1 trait, only now, we're doing so while the outputs are wrapped inside of whatever context we're using.

There is still a little syntactic sugar to make this even more convenient.
----------------------------------------------------------------------------------------
comboKleisli: Kleisli[Task, Id, Int] = Kleisli(getEmployeeFromDb) 
                                            andThenK processEmployeeKleisli 
                                                andThenK getEmployeeFromDbKleisli

So previously we'd lifted all of our functions into Kleisli in order to compose them, but the Kleisli itself provides the ability to perfrom both the lift and combination in a single step. You still need to lift the first function, but after that you can either use andThenK or composeK if you're using Scalaz, or Cats simply overloads the andThen operator so there's no change between providing a function or kleisli wrapped function in the chain.   

The only thing remaining to do is extract our combined function out of the kleisli that's wrapping it.
----------------------------------------------------------------------------------------
comboFn: Id => Task[Int] = (Kleisli(getEmployeeFromDb) 
                                    andThenK processEmployeeKleisli 
                                        andThenK getEmployeeFromDbKleisli).run

we do that by calling the run function on the kleisli.run

----------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------

                    
